# Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# generated using file ./gen/model/linux/network/ip/route.yaml
#
# DONOT EDIT - generated by diligent bots

from dent_os_testbed.lib.test_lib_object import TestLibObject
class LinuxIpRoute(TestLibObject):
    """
        - ip [ ip-OPTIONS ] route { COMMAND | help }
        - ip route { show | flush } SELECTOR
        - ip route save SELECTOR
        - ip route restore
        - ip route get ROUTE_GET_FLAGS ADDRESS [ from ADDRESS iif STRING ] [ oif STRING ] [ mark MARK ]
          [ tos TOS ] [ vrf NAME ] [ ipproto PROTOCOL ] [ sport NUMBER ] [ dport NUMBER ]
        - ip route { add | del | change | append | replace } ROUTE
        SELECTOR := [ root PREFIX ] [ match PREFIX ] [ exact PREFIX ] [ table TABLE_ID ] [ vrf NAME ]
          [ proto RTPROTO ] [ type TYPE ] [ scope SCOPE ]
        ROUTE := NODE_SPEC [ INFO_SPEC ]
        NODE_SPEC := [ TYPE ] PREFIX [ tos TOS ] [ table TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ]
          [ metric METRIC ] [ ttl-propagate { enabled | disabled } ]
        INFO_SPEC := NH OPTIONS FLAGS [ nexthop NH ] ...
        NH := [ encap ENCAP ] [ via [ FAMILY ] ADDRESS ] [ dev STRING ] [ weight NUMBER ] NHFLAGS
        FAMILY := [ inet | inet6 | ipx | dnet | mpls | bridge | link ]
        OPTIONS := FLAGS [ mtu NUMBER ] [ advmss NUMBER ] [ as [ to ] ADDRESS ] rtt TIME ] [ rttvar TIME ]
          [ reordering NUMBER ] [ window NUMBER ] [ cwnd NUMBER ] [ ssthresh NUMBER ] [ realms REALM ]
          [ rto_min TIME ] [ initcwnd NUMBER ] [ initrwnd NUMBER ] [ features FEATURES ] [ quickack BOOL ]
          [ congctl NAME ] [ pref PREF ] [ expires TIME ] [ fastopen_no_cookie BOOL ]
        TYPE := [ unicast | local | broadcast | multicast | throw | unreachable | prohibit | blackhole | nat ]
        TABLE_ID := [ local| main | default | all | NUMBER ]
        SCOPE := [ host | link | global | NUMBER ]
        NHFLAGS := [ onlink | pervasive ]
        RTPROTO := [ kernel | boot | static | NUMBER ]
        FEATURES := [ ecn | ]
        PREF := [ low | medium | high ]
        ENCAP := [ ENCAP_MPLS | ENCAP_IP | ENCAP_BPF | ENCAP_SEG6 | ENCAP_SEG6LOCAL ]
        ENCAP_MPLS := mpls [ LABEL ] [ ttl TTL ]
        ENCAP_IP := ip id TUNNEL_ID dst REMOTE_IP [ tos TOS ] [ ttl TTL ]
        ENCAP_BPF := bpf [ in PROG ] [ out PROG ] [ xmit PROG ] [ headroom SIZE ]
        ENCAP_SEG6 := seg6 mode [ encap | inline | l2encap ] segs SEGMENTS [ hmac KEYID ]
        ENCAP_SEG6LOCAL := seg6local action SEG6_ACTION [ SEG6_ACTION_PARAM ]
        ROUTE_GET_FLAGS := [ fibmatch ]

    """
    def format_update(self, command, *argv, **kwarg):
        raise NotImplementedError

    def parse_update(self, command, output, *argv, **kwarg):
        raise NotImplementedError

    def format_get(self, command, *argv, **kwarg):
        raise NotImplementedError

    def parse_get(self, command, output, *argv, **kwarg):
        raise NotImplementedError

    def format_restore(self, command, *argv, **kwarg):
        raise NotImplementedError

    def parse_restore(self, command, output, *argv, **kwarg):
        raise NotImplementedError

    def format_save(self, command, *argv, **kwarg):
        raise NotImplementedError

    def parse_save(self, command, output, *argv, **kwarg):
        raise NotImplementedError

    def format_show(self, command, *argv, **kwarg):
        raise NotImplementedError

    def parse_show(self, command, output, *argv, **kwarg):
        raise NotImplementedError

    def format_command(self, command, *argv, **kwarg):
        if command in ['add', 'delete', 'change', 'append', 'replace']:
            return self.format_update(command, *argv, **kwarg)

        if command in ['get']:
            return self.format_get(command, *argv, **kwarg)

        if command in ['restore']:
            return self.format_restore(command, *argv, **kwarg)

        if command in ['save']:
            return self.format_save(command, *argv, **kwarg)

        if command in ['show', 'flush']:
            return self.format_show(command, *argv, **kwarg)


        raise NameError("Cannot find command "+command)

    def parse_output(self, command, output, *argv, **kwarg):
        if command in ['add', 'delete', 'change', 'append', 'replace']:
            return self.parse_update(command, output, *argv, **kwarg)

        if command in ['get']:
            return self.parse_get(command, output, *argv, **kwarg)

        if command in ['restore']:
            return self.parse_restore(command, output, *argv, **kwarg)

        if command in ['save']:
            return self.parse_save(command, output, *argv, **kwarg)

        if command in ['show', 'flush']:
            return self.parse_show(command, output, *argv, **kwarg)


        raise NameError("Cannot find command "+command)

