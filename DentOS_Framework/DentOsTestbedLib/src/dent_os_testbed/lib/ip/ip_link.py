# Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# generated using file ./gen/model/dent/network/ip/link.yaml
#
# DONOT EDIT - generated by diligent bots

import pytest
from dent_os_testbed.lib.test_lib_object import TestLibObject
from dent_os_testbed.lib.ip.linux.linux_ip_link_impl import LinuxIpLinkImpl


class IpLink(TestLibObject):
    """
        ip-link - network device configuration

    """
    async def _run_command(api, *argv, **kwarg):
        devices = kwarg['input_data']
        result = list()
        for device in devices:
            for device_name in device:
                device_result = {
                    device_name : dict()
                }
                # device lookup
                if 'device_obj' in kwarg:
                    device_obj = kwarg.get('device_obj', None)[device_name]
                else:
                    if device_name not in pytest.testbed.devices_dict:
                        device_result[device_name] = 'No matching device ' + device_name
                        result.append(device_result)
                        return result
                    device_obj = pytest.testbed.devices_dict[device_name]
                commands = ''
                if device_obj.os in ['dentos', 'cumulus']:
                    impl_obj = LinuxIpLinkImpl()
                    for command in device[device_name]:
                        commands += impl_obj.format_command(command=api, params=command)
                        commands += '&& '
                    commands = commands[:-3]

                else:
                    device_result[device_name]['rc'] = -1
                    device_result[device_name]['result'] = 'No matching device OS ' + device_obj.os
                    result.append(device_result)
                    return result
                device_result[device_name]['command'] = commands
                try:
                    rc, output = await device_obj.run_cmd(('sudo ' if device_obj.ssh_conn_params.pssh else '') + commands)
                    device_result[device_name]['rc'] = rc
                    device_result[device_name]['result'] = output
                    if 'parse_output' in kwarg:
                        parse_output = impl_obj.parse_output(command=api, output=output, commands=commands)
                        device_result[device_name]['parsed_output'] = parse_output
                except Exception as e:
                    device_result[device_name]['rc'] = -1
                    device_result[device_name]['result'] = str(e)
                result.append(device_result)
        return result

    async def add(*argv, **kwarg):
        """
        Platforms: ['dentos', 'cumulus']
        Usage:
        IpLink.add(
            input_data = [{
                # device 1
                'dev1' : [{
                    # command 1
                        'dev':'undefined',
                        'name':'string',
                        'txqueuelen':'int',
                        'address':'mac_t',
                        'broadcast':'mac_t',
                        'mtu':'int',
                        'index':'undefined',
                        'numtxqueues':'undefined',
                        'numrxqueues':'undefined',
                        'gso_max_size':'int',
                        'gso_max_segs':'int',
                        'type':'undefined',
                        'options':'string',
                        'ageing_time':'int',
                }],
            }],
        )
        Description:
        - ip link add [ link DEVICE ] [ ageing_time AGEING_TIME ] [ name ] NAME [ txqueuelen PACKETS ] [ address LLADDR ] [ broadcast LLADDR ]
          [ mtu MTU ] [ index IDX ] [ numtxqueues QUEUE_COUNT ] [ numrxqueues QUEUE_COUNT ] [ gso_max_size BYTES ]
          [ gso_max_segs SEGMENTS ] type TYPE [ ARGS ]
        TYPE := [ bridge | bond | can | dummy | hsr | ifb | ipoib | macvlan | macvtap | vcan | vxcan | veth | vlan | vxlan
          | ip6tnl | ipip | sit | gre | gretap | erspan | ip6gre | ip6gretap | ip6erspan | vti | nlmon | ipvlan | ipvtap
          | lowpan | geneve | vrf | macsec | netdevsim | rmnet ]

        """
        return await IpLink._run_command('add', *argv, **kwarg)

    async def delete(*argv, **kwarg):
        """
        Platforms: ['dentos', 'cumulus']
        Usage:
        IpLink.delete(
            input_data = [{
                # device 1
                'dev1' : [{
                    # command 1
                        'device':'string',
                        'group':'string',
                        'type':'undefined',
                        'options':'string',
                }],
            }],
        )
        Description:
        - ip link delete { DEVICE | group GROUP } type TYPE [ ARGS ]
        TYPE := [ bridge | bond | can | dummy | hsr | ifb | ipoib | macvlan | macvtap | vcan | vxcan | veth | vlan | vxlan
          | ip6tnl | ipip | sit | gre | gretap | erspan | ip6gre | ip6gretap | ip6erspan | vti | nlmon | ipvlan | ipvtap
          | lowpan | geneve | vrf | macsec | netdevsim | rmnet ]

        """
        return await IpLink._run_command('delete', *argv, **kwarg)

    async def set(*argv, **kwarg):
        """
        Platforms: ['dentos', 'cumulus']
        Usage:
        IpLink.set(
            input_data = [{
                # device 1
                'dev1' : [{
                    # command 1
                        'device':'string',
                        'group':'string',
                        'up':'undefined',
                        'enable':'undefined',
                        'type':'undefined',
                        'arp':'bool',
                        'dynamic':'bool',
                        'multicast':'bool',
                        'allmulticast':'bool',
                        'promiscuity':'int',
                        'protodown':'undefined',
                        'trailers':'undefined',
                        'txqueuelen':'int',
                        'name':'string',
                        'address':'mac_t',
                        'broadcast':'mac_t',
                        'mtu':'int',
                        'netns':'int',
                        'link-netsid':'undefined',
                        'alias':'string',
                        'vf':'int',
                        'mac':'mac_t',
                        'rate':'int',
                        'max_tx_rate':'int',
                        'min_tx_rate':'int',
                        'spoofchk':'int',
                        'query_rss':'undefined',
                        'state':'string',
                        'trust':'undefined',
                        'node_guid':'undefined',
                        'port_guid':'undefined',
                        'xdp':'undefined',
                        'object':'undefined',
                        'section':'undefined',
                        'verbose':'undefined',
                        'pinned':'undefined',
                        'master':'string',
                        'nomaster':'bool',
                        'vrf':'undefined',
                        'addrgenmode':'undefined',
                        'maddr':'undefined',
                        'op':'undefined',
                        'mac_addr_list':'undefined',
                        'options':'string',
                        'ageing_time':'int',
                }],
            }],
        )
        Description:
        - ip link set { DEVICE | group GROUP } [ { up | down } ] [ type ETYPE TYPE_ARGS ] [ ageing_time AGEING_TIME ] [ arp { on | off } ]
          [ dynamic { on | off } ] [ multicast { on | off } ] [ allmulticast { on | off } ] [ promisc { on | off } ]
          [ protodown { on | off } ] [ trailers { on | off } ] [ txqueuelen PACKETS ] [ name NEWNAME ] [ address LLADDR ]
          [ broadcast LLADDR ] [ mtu MTU ] [ netns { PID | NETNSNAME } ] [ link-netnsid ID ] [ alias NAME ] [ vf NUM [ mac LLADDR ]
          [ VFVLAN-LIST ] [ rate TXRATE ] [ max_tx_rate TXRATE ] [ min_tx_rate TXRATE ] [ spoofchk { on | off } ]
          [ query_rss { on | off } ] [ state { auto | enable | disable } ] [ trust { on | off } ] [ node_guid eui64 ]
          [ port_guid eui64 ] ] [ { xdp | xdpgeneric | xdpdrv | xdpoffload } { off | object FILE [ section NAME ] [ verbose ] |
          pinned FILE } ] [ master DEVICE ] [ nomaster ] [ vrf NAME ] [ addrgenmode { eui64 | none | stable_secret | random } ]
          [ macaddr { flush | { add | del } MACADDR | set [ MACADDR [ MACADDR [ ... ] ] ] } ]

        """
        return await IpLink._run_command('set', *argv, **kwarg)

    async def show(*argv, **kwarg):
        """
        Platforms: ['dentos', 'cumulus']
        Usage:
        IpLink.show(
            input_data = [{
                # device 1
                'dev1' : [{
                    # command 1
                        'device':'string',
                        'group':'string',
                        'options':'string',
                }],
            }],
        )
        Description:
        ip link show [ DEVICE | group GROUP ]

        """
        return await IpLink._run_command('show', *argv, **kwarg)

    async def xstats(*argv, **kwarg):
        """
        Platforms: ['dentos', 'cumulus']
        Usage:
        IpLink.xstats(
            input_data = [{
                # device 1
                'dev1' : [{
                    # command 1
                        'device':'string',
                        'group':'string',
                        'options':'string',
                }],
            }],
        )
        Description:
        ip link show [ DEVICE | group GROUP ]

        """
        return await IpLink._run_command('xstats', *argv, **kwarg)

    async def afstats(*argv, **kwarg):
        """
        Platforms: ['dentos', 'cumulus']
        Usage:
        IpLink.afstats(
            input_data = [{
                # device 1
                'dev1' : [{
                    # command 1
                        'device':'string',
                        'group':'string',
                        'options':'string',
                }],
            }],
        )
        Description:
        ip link show [ DEVICE | group GROUP ]

        """
        return await IpLink._run_command('afstats', *argv, **kwarg)
